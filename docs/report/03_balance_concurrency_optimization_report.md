# Spring Retry 적용을 통한 낙관적 락 충돌 해결 전/후 비교

## 1. 개요

포인트 충전/차감 시스템에서 발생하는 낙관적 락 충돌 문제를 Spring Retry를 사용 전/후 비교를 위한 보고서

## 2. 문제 상황

### 2.1 낙관적 락과 동시성 충돌

낙관적 락은 데이터베이스 레벨에서 동시성을 제어하는 방법으로, 엔티티의 버전(`Version`) 정보를 통해 충돌을 감지한다.

여러 트랜잭션이 동시에 같은 데이터를 수정하려 할 때 `ObjectOptimisticLockingFailureException`이 발생한다.

### 2.2 테스트 결과 분석 (Spring Retry 적용 전)

| 테스트 케이스                            | 성공 | 실패 | 성공률 |
|------------------------------------|----|----|-----|
| 대량 포인트 충전 동시성 테스트 (50스레드, 100작업)   | 38 | 62 | 38% |
| 유저 포인트 차감 동시성 테스트 (5스레드, 10작업)     | 4  | 6  | 40% |
| 유저 포인트 충전 10번 동시성 테스트 (5스레드, 10작업) | 4  | 6  | 40% |

**주요 문제점**

- 동시성이 높을수록 충돌 발생률 급증
- 대량 작업에서 62%의 높은 실패율
- 비즈니스 로직은 정상이지만 기술적 충돌로 인한 실패

## 3. Spring Retry

### 3.1 Spring Retry란?

Spring Retry는 실패한 작업을 자동으로 재시도하는 기능을 제공하는 Spring 프레임워크의 모듈이다.

**핵심 특징**

- 어노테이션 기반의 간단한 설정으로 **선언적 재시도**가 가능하다.
- 재시도 간격을 조정하여 **시스템 부하 분산**이 가능하다.
- 특정 예외에 대해서만 재시도 수행할 수 있다. (동시성 충돌 해결하기 위해 특정 예외로 이번엔 `ObjectOptimisticLockingFailureException` 예외 발생 시 재시도 수행)
- 무한 재시도 방지하고자 **최대 재시도 횟수 제한**할 수 있다.

### 3.2 적용한 코드

```kotlin
class 예시 {
   @Retryable(
      value = [ObjectOptimisticLockingFailureException::class],
      maxAttempts = 3,
      backoff = Backoff(delay = 200)
   )
   fun charge(command: BalanceChargeCommand) {
      // 비즈니스 로직
   }
}
```

**설정 상세**

- `value`: `ObjectOptimisticLockingFailureException`만 재시도 대상으로 지정
- `maxAttempts`: 최대 3번까지 재시도 (원본 실행 1회 + 재시도 2회)
- `backoff.delay`: 재시도 간격을 200ms로 설정하여 충돌 확률 감소

### 3.3 재시도 메커니즘

**재시도 플로우**

1. 초기 요청 실행 → `OptimisticLockingFailureException` 발생
2. 200ms 대기 후 1차 재시도 → 실패 시 추가 200ms 대기
3. 2차 재시도 수행 → 최대 3회까지 시도
4. 모든 재시도 실패 시 최종 예외 발생

## 4. 성능 개선 결과

### 4.1 테스트 결과 비교 (Spring Retry 적용 후)

| 테스트 케이스               | 적용 전 성공/실패  | 적용 후 성공/실패  | 성공률 개선   |
|-----------------------|-------------|-------------|----------|
| 대량 포인트 충전 동시성 테스트     | 38/62 (38%) | 85/15 (85%) | **+47%** |
| 유저 포인트 차감 동시성 테스트     | 4/6 (40%)   | 9/1 (90%)   | **+50%** |
| 유저 포인트 충전 10번 동시성 테스트 | 4/6 (40%)   | 9/1 (90%)   | **+50%** |

### 4.2 상세 분석

#### 4.2.1 성공적인 개선 사례

**대량 포인트 충전 동시성 테스트**

- 가장 극적인 개선: 38% → 85% (47% 향상)
- 높은 동시성 환경에서 재시도의 효과가 극대화
- 기술적 충돌로 인한 실패를 크게 감소

**일반 충전/차감 테스트**

- 40% → 90%의 일관된 개선
- 적당한 동시성 환경에서도 안정적인 성능 향상

## 5. 핵심 인사이트

### 5.1 Spring Retry의 효과적인 적용 조건

1. **기술적 충돌 vs 비즈니스 실패**
    - 낙관적 락 충돌: 재시도로 해결 가능 ✅
    - 잔액 부족: 재시도로 해결 불가능 ❌

2. **동시성 수준과 개선 효과**
    - 높은 동시성 → 큰 개선 효과
    - 낮은 동시성 → 제한적 개선 효과

3. **백오프 전략의 중요성**
    - 200ms 지연으로 충돌 확률 감소
    - 시스템 부하 분산 효과

### 5.2 아키텍처적 이점

#### Spring Retry를 사용하지 않고 예외로 인한 재시도를 할 경우

```kotlin
try {
    balanceService.charge(command)
} catch (OptimisticLockingFailureException e) {
    // 수동 재시도 로직
    Thread.sleep(200)
    balanceService.charge(command)
}
```

#### Spring Retry를 사용할 경우

```kotlin
@Retryable(
    value = [ObjectOptimisticLockingFailureException::class],
    maxAttempts = 3,
    backoff = Backoff(delay = 200)
)
fun charge(command: BalanceChargeCommand) {
    // 비즈니스 로직에만 집중
}
```

## 6. 결론

Spring Retry 적용을 통해 낙관적 락 충돌로 인한 실패율을 현저히 개선되었다.

특히 기술적 충돌 상황에서 평균 47%의 성공률 향상을 달성했으며, 비즈니스 로직의 복잡성을 증가시키지 않고도 시스템의 안정성을 크게 개선되었다.

**핵심 성과**

- 📈 **성공률 대폭 개선**: 38% → 85% (대량 처리)
- 🎯 **선택적 적용**: 기술적 충돌만 대상으로 정확한 처리
- 🔧 **코드 간소화**: 선언적 어노테이션으로 복잡한 재시도 로직 대체
- 🚀 **확장성 확보**: 높은 동시성 환경에서도 안정적인 처리 가능