# 선착순 쿠폰 발급(feat.Redis)

Redis 도입으로 인한 성능 향상 전/후 비교에 대한 보고서

## Redis 사용 이유

- 선착순 쿠폰은 발급 가능 시간이 될 때 과도한 요청으로 트래픽이 과부하될 수 있음
- 만약 DB에 직접적으로 쓰기/읽기를 할 경우
    - 디스크 I/O 병목: 대량의 동시 요청이 디스크 기반 DB에 집중되어 성능 저하
    - Lock 경합: 재고 차감을 위한 SELECT FOR UPDATE 시 심각한 경합 발생
    - Connection Pool 고갈: DB 커넥션 부족으로 응답 불가 상황 발생
    - 트랜잭션 지연: 긴 트랜잭션으로 인한 전체 시스템 성능 저하

## Redis 장점

### 1. 메모리 기반 고속 처리

- 디스크 I/O 없이 메모리에서 직접 처리하여 응답속도 향상
- 초당 수만 건의 요청 처리 가능

### 2. 원자성(Atomicity) 보장

- 단일 스레드 모델로 Race Condition 방지
- Lua Script를 통한 복합 연산의 원자적 실행

### 3. 동시성 제어

- 별도의 Lock 없이도 안전한 동시성 처리
- SET 자료구조로 중복 발급 방지

## 구현 전략

### 데이터 구조

```text
coupon:stock:{couponId}        → 남은 쿠폰 수량 (String)
coupon:issued:set:{couponId}   → 발급받은 사용자 ID 집합 (Set)
```

### 핵심 로직 (Lua Script)

```lua
local stockKey = KEYS[1]    -- 재고 키
local issuedKey = KEYS[2]   -- 발급 이력 키  
local userId = ARGV[1]      -- 사용자 ID

-- 1. 중복 발급 체크
if redis.call('SADD', issuedKey, userId) == 0 then
    return 'ALREADY_ISSUED'
end

-- 2. 재고 확인 및 차감
local currentStock = redis.call('GET', stockKey)
if not currentStock or tonumber(currentStock) <= 0 then
    redis.call('SREM', issuedKey, userId)  -- 롤백
    return 'SOLD_OUT'
end

-- 3. 재고 차감
local newStock = redis.call('DECR', stockKey)
if newStock < 0 then
    redis.call('INCR', stockKey)           -- 복구
    redis.call('SREM', issuedKey, userId)  -- 롤백
    return 'SOLD_OUT'
end

return 'SUCCESS'
```

## 동시성 문제 해결

### 1. 중복 발급 방지

- Redis SET의 `SADD` 명령어 활용
- 이미 존재하는 사용자 ID는 추가되지 않음 (반환값: 0)

### 2. 재고 과차감 방지

- `DECR` 후 음수 체크로 과발급 감지
- 실패 시 `INCR`로 재고 복구 및 사용자 `Set`에서 제거

### 3. 원자적 실행

- 모든 검증과 차감 로직이 하나의 Lua Script로 실행
- 중간에 다른 요청이 끼어들 수 없음

## 실제 구현 코드

### Repository

```kotlin
@Repository
class CouponRedisRepositoryImpl(
    private val redisTemplate: RedisTemplate<String, Any>
) : CouponRedisRepository {
    companion object {
        const val COUPON_STOCK_KEY = "coupon:stock:%s"
        const val COUPON_ISSUED_SET = "coupon:issued:set:%d"
    }

    override fun issueRequest(userId: Long, couponId: Long): String {

        val issuedKey = COUPON_ISSUED_SET.format(couponId)

        return redisTemplate.execute(
            luaScript,
            listOf(stockKey, issuedKey),
            userId.toString()
        )
    }
}
```

- `Repository`에서 Lua Script를 실행하여 쿠폰 발급하고 상태(`ALREADY_ISSUED`, `SOLD_OUT`,`SUCCESS`)를 반환

### Service

```kotlin
@Service
class CouponService(
    private val couponRedisRepository: CouponRedisRepository
) {
    fun issue(command: CouponIssueCommand) {
        val status = couponRedisRepository.issueRequest(command.userId, command.couponId)

        when (status) {
            "ALREADY_ISSUED" -> throw BusinessException(ErrorCode.COUPON_ALREADY_ISSUED)
            "SOLD_OUT" -> throw BusinessException(ErrorCode.COUPON_SOLD_OUT)
            "SUCCESS" -> {}

            else -> throw BusinessException(ErrorCode.UNKNOWN_ERROR)
        }
    }
}
```

- 반환된 상태에 맞게 예외 발생 및 처리

> 발급 성공(SUCCESS) 할 경우에 대한 처리는 추후에 Kafka 적용 예정

## 성능 비교 (K6 부하테스트 결과)

### 테스트 환경

- 부하 조건: 10초 동안 1000명 동시 접속
- 쿠폰 수량: 100개 (선착순)
- 도구: K6 Load Testing

### 상세 비교 결과

| 지표            | 분산 락 (Redis 적용 전) | Redis + Lua Script | 개선 효과       |
|---------------|-------------------|--------------------|-------------|
| **평균 응답시간**   | 448.26ms          | 7.46ms             | **60배 개선**  |
| **P95 응답시간**  | 874.5ms           | 31.88ms            | **27배 개선**  |
| **처리량 (RPS)** | 233.9 req/s       | 2,644.4 req/s      | **11배 개선**  |
| **총 요청 수**    | 2,783개            | 27,040개            | **9.7배 증가** |
| **성공률**       | 3.59% (100/2783)  | 0.36% (100/27040)  | 동일한 성공 건수   |

### 주요 개선 사항
#### 1. 응답시간 대폭 개선
```text
평균 응답시간: 448ms → 7ms (98% 단축)
P95 응답시간: 875ms → 32ms (96% 단축)
```

#### 2. 처리량 대폭 증가
```text
초당 요청 처리: 234 → 2,644 (11배 증가)
10초간 총 처리: 2,783 → 27,040 (9.7배 증가)
```

### 성능 그래프 비교

```
응답시간 분포
████████████████████████████ (분산 락 - 448ms 평균)
██ (Redis - 7ms 평균)

처리량
████ (분산락 - 234 RPS)
████████████████████████████████████████ (Redis - 2,644 RPS)
```

#### Before (분산 락)
- 🔴 **사용자 경험**: 평균 0.4초 대기, 96% 실패율
- 🔴 **서버 부하**: 높은 CPU 사용률, 메모리 부족
- 🔴 **확장성**: 트래픽 증가 시 성능 급격히 저하

#### After (Redis)
- ✅ **사용자 경험**: 평균 0.007초 응답, 빠른 성공/실패 판단
- ✅ **서버 안정성**: 낮은 리소스 사용률, 안정적 처리
- ✅ **확장성**: 트래픽 증가해도 일정한 성능 유지

## Sorted Set 대신 String 기반으로 설계한 이유

선착순 쿠폰 발급 기능에서는 발급 처리 자체가 선착순으로 즉시 이루어져야 한다고 판단했습니다.<br/>
Sorted Set을 사용한 비동기 처리 방식의 경우, 아래과 같은 문제점이 있다고 생각했습니다.
- 사용자가 요청 후 실제 처리가 완료될 때까지 발급 성공 여부를 알 수 없음 
- 쿠폰이 이미 소진되었음에도 사용자가 이를 즉시 인지하지 못함 
- 대기 상태에서 발생하는 불확실성으로 인한 사용자 경험 저하

따라서 아래와 같은 이유로 Lua Script를 활용한 String 기반 설계를 선택했습니다.
- 쿠폰 재고 확인과 차감을 원자적으로 처리 
- 재고 부족 시 즉시 마감 예외를 사용자에게 전달 
- 발급 성공/실패를 실시간으로 응답하여 명확한 사용자 피드백 제공

이를 통해 선착순이라는 비즈니스 요구사항에 맞춰 즉시성과 정확성을 모두 보장할 수 있도록 구현했습니다.