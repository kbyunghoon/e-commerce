# ì‹¤ì‹œê°„ ë­í‚¹ ì‹œìŠ¤í…œ ë° ë¹„ë™ê¸° ì²˜ë¦¬ ì„¤ê³„/ê°œë°œ íšŒê³  ë³´ê³ ì„œ

## ğŸ“‹ ëª©ì°¨

1. [ì‹œìŠ¤í…œ ì„¤ê³„](#ì‹œìŠ¤í…œ-ì„¤ê³„)
2. [í•µì‹¬ ì„¤ê³„ ì›ì¹™](#í•µì‹¬-ì„¤ê³„-ì›ì¹™)
3. [êµ¬í˜„ ê³¼ì •](#êµ¬í˜„-ê³¼ì •)

## ì‹œìŠ¤í…œ ì„¤ê³„

### ì „ì²´ ì•„í‚¤í…ì²˜

```mermaid
graph TB
    Client[í´ë¼ì´ì–¸íŠ¸] --> API[API Gateway]
    API --> ProductService[Product Service]
    API --> RankingService[Ranking Service]
    ProductService --> DB[(MySQL)]
    ProductService --> EventPublisher[Event Publisher]
    EventPublisher --> EventListener[Event Listener]
    EventListener --> RankingService
    RankingService --> Redis[(Redis)]
    RankingService --> BackupService[Backup Service]
    BackupService --> DB
    Scheduler[Scheduler] --> RankingService
    Scheduler --> BackupService
```

### í•µì‹¬ ì„¤ê³„ ì›ì¹™

#### 1. ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜

```kotlin
@Service
class ProductService() {
    @Transactional
    fun deductStock(productId: Long, quantity: Int) {
        val product = productRepository.findByIdWithPessimisticLock(productId)
        val previousStock = product.stock

        product.deductStock(quantity)
        val updatedProduct = productRepository.save(product)

        // ì¬ê³  ë³€ê²½ ì‹œ ì´ë²¤íŠ¸ ë°œí–‰
        applicationEventPublisher.publishEvent(
            StockChangedEvent(
                productId = productId,
                changeType = StockChangeType.DEDUCT,
                changeQuantity = quantity,
                previousStock = previousStock,
                currentStock = updatedProduct.stock,
                reason = StockChangeType.DEDUCT.reason
            )
        )
    }
}
```

### 2. ê³„ì¸µí˜• ì•„í‚¤í…ì²˜ (Clean Architecture)

```
â”œâ”€â”€ presentation/     # Controller Layer
â”œâ”€â”€ application/      # Service Layer  
â”œâ”€â”€ domain/          # Domain Layer
â””â”€â”€ infrastructure/  # Infrastructure Layer
    â”œâ”€â”€ persistence/
    â”œâ”€â”€ scheduler/
    â””â”€â”€ event/
```

## êµ¬í˜„ ê³¼ì •

### 1ë‹¨ê³„: ë„ë©”ì¸ ëª¨ë¸ë§

#### ë­í‚¹ ë°ì´í„° êµ¬ì¡° ì„¤ê³„

```kotlin
data class ProductRankingCache(
    val productId: Long,
    val totalSalesCount: Int
)

enum class StockChangeType(
    val reason: String,
    val affectsRanking: Boolean = false
) {
    DEDUCT("ìƒí’ˆ ì£¼ë¬¸ìœ¼ë¡œ ì¸í•œ ì¬ê³  ì°¨ê°", affectsRanking = true),
    RESTORE("ì£¼ë¬¸ ì·¨ì†Œë¡œ ì¸í•œ ì¬ê³  ë³µì›", affectsRanking = false)
}
```

### 2ë‹¨ê³„: Redis ê¸°ë°˜ ë­í‚¹ ì‹œìŠ¤í…œ êµ¬í˜„

#### Redisson Sorted Set í™œìš©
```kotlin
@Repository
class ProductRedissonRepositoryImpl(
    private val redissonClient: RedissonClient,
) : ProductRedissonRepository {

    override fun increaseScore(productId: Long, quantity: Int) {
        val today = LocalDate.now()
        val score = quantity.toDouble()

        // ì¼ê°„ ë­í‚¹ ì—…ë°ì´íŠ¸
        val dailyKey = PRODUCT_RANKING_DAILY.format(today.format(DAILY_FORMAT))
        updateScoreForKey(dailyKey, productId.toString(), score)

        // ì£¼ê°„ ë­í‚¹ ì—…ë°ì´íŠ¸
        val weekFields = WeekFields.of(Locale.getDefault())
        val weeklyDate = today.with(weekFields.dayOfWeek(), 1)
        val weeklyKey = PRODUCT_RANKING_WEEKLY.format(weeklyDate.format(WEEKLY_FORMAT))
        updateScoreForKey(weeklyKey, productId.toString(), score)
    }

    // Score ì—…ë°ì´íŠ¸ í•˜ëŠ” ë©”ì„œë“œ
    private fun updateScoreForKey(key: String, member: String, score: Double) {
        val sortedSet = redissonClient.getScoredSortedSet<String>(key)

        sortedSet.addScore(member, score)
    }
}
```

#### í•µì‹¬ ì„¤ê³„ ê²°ì •ì‚¬í•­
1. **í‚¤ êµ¬ì„± ì „ëµ**: `product:ranking:daily:2025-08-22`, `product:ranking:weekly:2024-W18` 
2. **ì ìˆ˜ ëˆ„ì **: `addScore()` ë©”ì„œë“œë¡œ ê¸°ì¡´ ì ìˆ˜ì— ëˆ„ì 
3. **ì •ë ¬ ë°©ì‹**: `entryRangeReversed()`ë¡œ `Score` ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬

### 3ë‹¨ê³„: ì´ë²¤íŠ¸ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬

#### ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ êµ¬í˜„
```kotlin
@Component
class ProductStockEventListener(
    private val productStockHistoryRepository: ProductStockHistoryRepository,
    private val productRankingService: ProductRankingService
) {

    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    fun handleStockChanged(event: StockChangedEvent) {
        val history = ProductStockHistory(
            productId = event.productId,
            changeType = event.changeType,
            changeQuantity = event.changeQuantity,
            previousStock = event.previousStock,
            currentStock = event.currentStock,
            reason = event.reason
        )

        productService.saveProductStockHistory(history)

        when (event.changeType) {
            StockChangeType.DEDUCT -> productRankingService.increaseProductStockCache(
                event.productId,
                event.changeQuantity
            )

            else -> {
                // ì¬ê³  ë³µì› ë“±ì— ëŒ€í•œ ì½”ë“œ
            }
        }
    }
}
```

#### ë¹„ë™ê¸° ì²˜ë¦¬ì˜ ì´ì 
- ë©”ì¸ ë¡œì§ê³¼ ë­í‚¹ ì—…ë°ì´íŠ¸ ë¶„ë¦¬
- ë­í‚¹ ì‹œìŠ¤í…œ ì¥ì• ê°€ ì£¼ë¬¸ í”„ë¡œì„¸ìŠ¤ì— ì˜í–¥ ì—†ìŒ
- ì´ë²¤íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€ ìš©ì´

#### ìŠ¤ì¼€ì¤„ëŸ¬ ê¸°ë°˜ ìë™ ë°±ì—…
```kotlin
@Component
class ProductRankingScheduler(
    private val productRankingService: ProductRankingService
) {
    
    @Scheduled(cron = "0 0 2 * * *") // ë§¤ì¼ ìƒˆë²½ 2ì‹œ
    fun initializeDailyRanking() {
        val today = LocalDate.now()
        val yesterday = today.minusDays(1)

        productRankingService.backupDailyRanking(yesterday)

        productRankingService.cleanupDailyRanking(yesterday)
    }

    @Scheduled(cron = "0 0 3 * * MON") // ë§¤ì£¼ ìƒˆë²½ 3ì‹œ
    fun initializeWeeklyRanking() {
        val today = LocalDate.now()
        val yesterday = today.minusDays(1)

        productRankingService.cleanupWeeklyRanking(yesterday)
    }
}
```
- ì¼ê°„ ì¸ê¸° ìƒí’ˆ : ë§¤ì¼ ìƒˆë²½ 2ì‹œì— Redisì— ìˆëŠ” ì‘ì¼ ìƒí’ˆ ë­í‚¹ ë°ì´í„°ë¥¼ DBì— ì €ì¥ ë° Redis ë°ì´í„° ì‚­ì œ
- ì£¼ê°„ ì¸ê¸° ìƒí’ˆ : ë§¤ì£¼ ìƒˆë²½ 3ì‹œì— Redisì— ìˆëŠ” ì‘ì£¼ ìƒí’ˆ ë­í‚¹ ë°ì´í„°ë¥¼ DBì— ì €ì¥ ë° Redis ë°ì´í„° ì‚­ì œ